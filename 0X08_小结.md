# 0X08 小结

之前的8期大致介绍了EBNF和它的一些应用。这一期我们对之前的知识做一个总结并且给出一些拓展的学习了解方向。

## 一些未解决问题

在写这个系列的教程的过程中，其实遇到几个到现在也没有查到权威回复的问题。这些问题主要集中在对EBNF的标准文件ISO/IEC 14977:1996的理解上。

其一是标准文件中提到了6.8，6.9这两节。但是实际上标准里没有写上（或者我没有找到）这两节。

其二是在用EBNF定义其本身的时候，对“syntax”一词的定义问题。

在标准文件中EBNF的定义被分为四个段落。在这四个段落中“syntax”各被定义了一次。如何理解这四次定义我还有点疑惑。是应该把四次定义理解为“或”的关系，还是“且”的关系？是同时满足这四次定义的才是“syntax”，还是只要满足这定义中的一个就是“syntax”？

就以上两个问题搜索没有什么结果后我发邮件给ISO Central Secretariat咨询。ISO Central Secretariat回复说他们只负责协调工作，没有负责回答问题的专家。建议我向ISO会员SAC咨询。然后我就又发邮件给SAC。结果SAC没有回复我的邮件。

过了几天我又想起来ANSI也是ISO的成员。所以又把同样的问题发给ANSI。然后ANSI回复我说他们没有和这个标准相关的专家委员会。给我推荐了一个专家。我给专家发的邮件当时就收到一个自动回复，说邮箱主人正在出差，有空再处理我的邮件。但是直到现在我还没有收到相关问题的回答，所以我也不敢说我把这俩问题弄明白了。

不过暂时我认为有两节缺失的问题是因为ISO/IEC 14977:1996起草后还没有完善。少写了两节。（也有可能是人为失误。）

而syntax被定义四次，我从实现分析器的角度考虑认为是这样的：

syntax被定义四次，代表从一个未被分析字符串到结构清楚的EBNF语句需要经过四道工序的处理。比如第一次处理清除无意义的空格。第二次清除所有注释。第三次词法分析划出单词。第四次语法分析。每一个EBNF语句同时满足这四条定义，但是不是简单的且的关系。因为这四次处理有先后顺序，比如不去除无效空格，一些单词就可能被分割或者被误认为别的单词。

## 一些拓展学习方向

EBNF只是一种比较简单的元语言。用于定义编程语言的语言其实还有其他。更深入地讨论下去，还可以接触到编译原理上的知识。

说到编译原理，国内教材基本上是干讲理论。如果想亲手实现一个小语言的编译器，可以去掌握一些编译器生成工具。例如flex，lex用于生成词法分析器。yacc，bison则用于生成语法分析器。

当然了，并不是所有人都需要去写一个编译器。除了去学编译原理，还有很多地方可以用到元语言。比如你学起编程语言可能更快了。从元语言的角度去审视C的语法描述，bash的命令格式，正则表达式之类的东西，可能会有一些新的理解。